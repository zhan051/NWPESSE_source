/*
 *      ABCluster
 *
 * Copyright (c) 2015 Jun Zhang
 * All rights reserved.
 *
 * The source code in this file is part of ABCluster, and is provided under 
 * a licence and may be used, copied, transmitted, or stored only in accord 
 * with that licence.
 *
 */

#include "CalculationEngine.h"
#include "CEResult.h"
#include "RMCluster.h"
#include "tinyfun.h"
#include "RunStatus.h"
#include <string>
#include <boost/spirit/include/classic.hpp>
#include <fstream>
#include <sstream>
#include <vector>
#include <cstdlib>
#include <cstdio>

using namespace abcluster;
using namespace boost::spirit::classic;
using namespace std;


CalculationEngine::CalculationEngine(void) 
{
    /* Nothing to do */
}

CalculationEngine::~CalculationEngine(void) 
{
    /* Nothing to do */
}

// Perform a local optimization.
// Return: double Energy, optimized X
double CalculationEngine::LocalOptimization(RMCluster& rmc, string& state, CEResult& cer, const string& label, const vector<string>& optcmds, const string& node)
{
    string inpfn = label+".xxxxxyz";
    string outfn = label+".ooooout";
    
    WriteInputXYZFile(rmc, inpfn);
    RunExternalProgram(optcmds, inpfn, outfn, label, node);
    ReadOutputXYZFile(rmc, state, cer, outfn);
    DeleteTmpFiles(inpfn, outfn);
    return cer.GetEnergy();
}

void CalculationEngine::RunExternalProgram(const vector<string>& optcmds, const string& inpfn, const string& outfn, const string& label, const string& node) const
{
    const string InputWildcard("$inp$");
    const string OutputWildcard("$out$");
    const string LabelWildcard("$xxx$");

    int ncmds = optcmds.size();
    for(int i = 0; i < ncmds; ++i) 
    {
        string tstr = optcmds[i];
	string tcmd = replaceall(tstr, InputWildcard, inpfn);
	tcmd = replaceall(tcmd, OutputWildcard, outfn);
	tcmd = replaceall(tcmd, LabelWildcard, label);
	
        string sshcmd;
        if(node != "" && tcmd != "") { sshcmd += "ssh -q "+node+" "; }
        tcmd = sshcmd+tcmd;        
        
        int iflag = system(tcmd.c_str());
	//if(iflag != RunStatus::Succeed)
	//{
	//    RunStatus::Warning("Fail to run the command [ %s ] for external program calculation.", tcmd.c_str());
	//}
    }
}

void CalculationEngine::WriteInputXYZFile(const RMCluster& rmc, const string& fn) const
{
    rmc.SaveAsXYZ(fn);
}

void CalculationEngine::ReadOutputXYZFile(RMCluster& rmc, string& state, CEResult& cer, const string& fn) const
{
    ifstream fd(fn.c_str(), ios::in);
    if(!fd.is_open()) 
    { 
        state.assign(string("The structure is not updated due to the calculation error."));
        rmc.SetEnergy(nan(""));
        return;
    }
    string filecontent((istreambuf_iterator<char>(fd)), istreambuf_iterator<char>());
    fd.close();

    string tstr;
    istringstream iss(filecontent);

    // Parse number of atoms
    int tn;    
    const rule<> RULE_int = (*blank_p)>>(int_p)[assign(tn)]>>(*blank_p);
    getline(iss, tstr, '\n');
    parse_info<> parser = parse(tstr.c_str(), RULE_int);
    if(!parser.full)
    {
	tstr = string("The structure is not updated due to the calculation error.");
        rmc.SetEnergy(nan(""));
        state.assign(tstr);
	return;
    }
    
    // Parse comment
    double td;
    const rule<> RULE_energy = (*blank_p)>>(real_p)[assign(td)]>>(*blank_p);
    getline(iss, tstr, '\n');
    parser = parse(tstr.c_str(), RULE_energy);
    if(parser.full)
    {
        rmc.SetEnergy(td);
        state.assign("Succeed");
    }
    else
    {
        rmc.SetEnergy(nan(""));
        state.assign(tstr);
    }

    // Parse coordinates
    string te;
    double tx, ty, tz;
    const rule<> RULE_xyz = (*blank_p)>>(*alnum_p)[assign(te)]>>
	(*blank_p)>>(real_p)[assign(tx)]>>
	(*blank_p)>>(real_p)[assign(ty)]>>
	(*blank_p)>>(real_p)[assign(tz)]>>
	(*blank_p);
    vector<string> symbols; symbols.clear();
    vector<double> x; x.clear();
    for(unsigned int i = 0; i < tn; ++i)
    {
	getline(iss, tstr, '\n');
	parser = parse(tstr.c_str(), RULE_xyz);
        if(!parser.full)
        { 
	    RunStatus::ErrorTermination("Incorrect XYZ file [ %s ] format generated by external program near: \" %s \".", 
		    fn.c_str(), tstr.c_str());
        }
        symbols.push_back(te);
        x.push_back(tx);
        x.push_back(ty);
        x.push_back(tz);
    }

    // Result
    cer.SetN(tn);
    cer.SetEnergy(td);
    cer.SetX(x);
    cer.SetSymbols(symbols);
}

void CalculationEngine::DeleteTmpFiles(const string& inpfn, const string& outfn) const
{
    remove(inpfn.c_str());
    remove(outfn.c_str());
}
